{% extends "./layout.html" %} {% block title %}A5-Security Misconfiguration{% endblock %} {% block content %}
<div class="row">
    <div class="col-lg-12">
        <div class="bs-example" style="margin-bottom: 40px;">
            <span class="label label-danger">Exploitability: EASY</span>
            <span class="label label-warning">Prevalence: COMMON</span>
            <span class="label label-danger">Detectability: EASY</span>
            <span class="label label-warning">Technical Impact: MODERATE</span>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-lg-12">
        <div class="panel panel-info">
            <div class="panel-heading">
                <h3 class="panel-title">Description</h3>
            </div>
            <div class="panel-body">
                <p>This vulnerability allows an attacker to accesses default accounts, unused pages, unpatched flaws, unprotected files and directories, etc. to gain unauthorized access to or knowledge of the system.</p>
                <p>Security misconfiguration can happen at any level of an application stack, including the platform, web server, application server, database, framework, and custom code.</p>
                <p>Developers and system administrators need to work together to ensure that the entire stack is configured properly.</p>
            </div>
        </div>
        <div class="panel panel-info">
            <div class="panel-heading">
                <h3 class="panel-title">Attack Mechanics</h3>
            </div>
            <div class="panel-body">

                This vulnerability encompasses a broad category of attacks, but here are some ways attacker can exploit it:
                <ol>
                    <li>If application server is configured to run as root, an attacker can run malicious scripts (by exploiting eval family functions) or start new child processes on server</li>
                    <li>Read, write, delete files on file system. Create and run binary files</li>
                    <li>If the server is misconfigured to leak internal implementation details via cookie names or HTTP response headers, then attacker can use this information towards building site's risk profile and finding vulnerabilities
                    </li>
                    <li>If request body size is not limited, an attacker can upload large size of input payload, causing server to run out of memory, or make processor and event loop busy.</li>
                </ol>

            </div>
        </div>
        <div class="panel panel-info">
            <div class="panel-heading">
                <h3 class="panel-title">How Do I Prevent It?</h3>
            </div>
            <div class="panel-body">
                Here are some node.js and express specific configuration measures:
                <ul>
                    <li>
                        Use latest stable version of node.js and express (or other web framework you are using). Keep a watch on published vulnerabilities of these. The vulnerabilities for node.js and express.js can be found <a href="http://blog.nodejs.org/vulnerability/">here</a> and
                        <a href="http://expressjs.com/advanced/security-updates.html">here</a>, respectively.
                    </li>
                    <li>
                        Do not run application with root privileges. It may seem necessary to run as root user to access privileged ports such as 80. However, this can achieved either by starting server as root and then downgrading the non-privileged user after listening on port 80 is established, or using a separate proxy, or using port mapping.</li>
                    <li>
                        Review default in HTTP Response headers to prevent internal implementation disclosure.
                    </li>
                    <li>
                        Use generic session cookie names
                    </li>
                    <li>
                        Limit HTTP Request Body size by setting sensible size limits on each content type specific middleware (
                        <code>urlencoded, json, multipart</code>) instead of using aggregate
                        <code>limit</code>middleware. Include only required middleware. For example if application doesn't need to support file uploads, do not include multipart middleware.
                        <li>
                            If using multipart middleware, have a strategy to clean up temporary files generated by it. These files are not garbage collected by default, and an attacker can fill disk with such temporary files
                        </li>
                        <li>
                            Vet npm packages used by the application
                        </li>
                        <li>
                            Lock versions of all npm packages used, for example using <a href="https://www.npmjs.org/doc/cli/npm-shrinkwrap.html"> shrinkwarp</a>, to have full control over when to install a new version of the package.
                        </li>
                        <li>
                            Set security specific HTTP headers
                        </li>
                </ul>
            </div>
        </div>
        <div class="panel panel-info">
            <div class="panel-heading">
                <h3 class="panel-title">Source Code Example</h3>
            </div>
            <div class="panel-body">
                <div>
                    <iframe width="560" height="315" src="//www.youtube.com/embed/lCpnVrD2Neg?rel=0" frameborder="0" allowfullscreen></iframe>
                </div>
                <p>The default HTTP header x-powered-by can reveal implementation details to an attacker. It can be taken out by including this code in
                    <code>server.js</code>
                    <pre>   
        app.disable("x-powered-by"); 
    </pre>
                </p>
                <p>The default session cookie name for express sessions can be changed by setting key attribute while creating express session.
                    <pre>
        app.use(express.session({
            secret: config.cookieSecret,
            key: "sessionId",
            cookie: {
                httpOnly: true,
                secure: true
            }
        }));
    </pre>
                </p>
                <p>The security related HTTP Headers can be added using helmet middleware as below
                    <pre>
        // Prevent opening page in frame or iframe to protect from clickjacking
        app.disable("x-powered-by");

        // Prevent opening page in frame or iframe to protect from clickjacking
        app.use(helmet.xframe());

        // Prevents browser from caching and storing page
        app.use(helmet.noCache());

        // Allow loading resources only from white-listed domains
        app.use(helmet.csp());

        // Allow communication only on HTTPS
        app.use(helmet.hsts());

        // Forces browser to only use the Content-Type set in the response header instead of sniffing or guessing it
        app.use(nosniff());

</pre>
                </p>
            </div>
        </div>
    </div>
</div>
{% endblock %}
